---
title: "Untitled"
author: "Emma Jones"
date: "1/18/2023"
output: html_document
---



### Water Column Metals

There are three functions that support the surface water metals assessment. These functions are used to determine criteria, identify exceedances of those criteria, and report these results in the stations table format. Surface water metals criteria are dependent on the designated use (aquatic life or human health). The aquatic life use is subdivided into freshwater and saltwater, which are further subdivided into acute and chronic criteria. The human health designated use is subdivided into public water supply and all other surface waters. Some criteria are specified outright, but a subset of criteria require calculation, which can involve a combination of variables (i.e., hardness, water effect ratio, and correction factor). For more information on surface water metals criteria see [9VAC25-260-140](https://law.lis.virginia.gov/admincode/title9/agency25/chapter260/section140/){target="_blank"}. The functions that are used to assess surface water metals are further described below.

Metals assessed for Aquatic Life Use designations use the rolling window analysis procedure detailed in the [Ammonia](#ammonia) section. 

![](images/MetalsFig.png)

#### metalsCriteriaFunction

This function is used to determine the criteria for a given sample, which are then applied against the metal concentrations of that sample. The function takes inputs of ID, Hardness, and WER. The ID field is a unique identifier for a sampling event. Hardness represents the hardness of the water associated with the sampling event in question. WER is the water effects ratio, which is "determined by measuring the effect of receiving water (as it is or will be affected by any discharges) on the bioavailability or toxicity of a metal by using standard test organisms and a metal to conduct toxicity tests simultaneously in receiving water and laboratory water.". The WER is set to 1 unless an "applicant or permittee demonstrates to the department's satisfaction in a permit proceeding that another value is appropriate, or unless available data allow the department to compute a WER for the receiving waters.". The formulae used in this function to produce the criteria were extracted from [9VAC25-260-140](https://law.lis.virginia.gov/admincode/title9/agency25/chapter260/section140/). Output criteria are set to 2 significant figures. This function is used as part of `metalsAnalysis()` , a separate function that is described below.

```{r automated assessment metalsCriteriaFunction, eval=FALSE}
# Metals criteria analysis
metalsCriteriaFunction <- function(ID, Hardness, WER){
  # Remember: ln is really log() in R; exp() is natural antilog in R
  # Per 9VAC25-260-140, criteria to 2 sig figs #https://law.lis.virginia.gov/admincode/title9/agency25/chapter260/section140/
  
  # If no WER supplied, use 1
  WER <- ifelse(is.na(WER), 1, WER)
  # Establish Hardness Criteria
  criteriaHardness <- ifelse(Hardness < 25, 25, ifelse(Hardness > 400, 400, Hardness))
  
  metalsCriteria <- suppressWarnings(
    tibble(ID= ID, `Antimony PWS` = 5.6, `Antimony All Other Surface Waters` = 640,
           `Arsenic Acute Freshwater` = 340, `Arsenic Chronic Freshwater` = 150, `Arsenic PWS` = 10,
           `Arsenic Acute Saltwater` = 69, `Arsenic Chronic Saltwater` = 36,
           `Barium PWS` = 2000,
           `Cadmium Acute Freshwater` =  signif(WER * exp(0.9789 * (log(criteriaHardness))-3.866) * (1.136672 - (log(criteriaHardness) * 0.041838)), digits = 2),
           `Cadmium Chronic Freshwater` = signif(WER * exp(0.7977 * log(criteriaHardness) - 3.909) * (1.101672 - (log(criteriaHardness) * (0.041838))), digits = 2),
           `Cadmium Acute Saltwater` = signif(33 * WER, digits = 2), `Cadmium Chronic Saltwater` = signif(7.9 * WER, digits = 2), `Cadmium PWS` = 5,
           `ChromiumIII Acute Freshwater` = signif(WER *  (exp(0.8190 * (log(criteriaHardness)) + 3.7256)) * 0.316, digits = 2), 
           `ChromiumIII Chronic Freshwater` = signif(WER *  (exp(0.8190 * (log(criteriaHardness))  +0.6848)) * 0.860, digits = 2), `ChromiumIII PWS` = 100,
           `ChromiumVI Acute Freshwater` = 16, `ChromiumVI Chronic Freshwater` = 11, `ChromiumVI Acute Saltwater` = 1100, `ChromiumVI Chronic Saltwater` = 50, 
           `Copper Acute Freshwater` =  signif(WER * (exp(0.9422 * log(criteriaHardness) - 1.700)) * 0.960, digits = 2),
           `Copper Chronic Freshwater` = signif(WER * (exp(0.8545 * log(criteriaHardness) - 1.702)) * 0.960, digits = 2),
           `Copper Acute Saltwater` =  signif(9.3 * WER, digits = 2), `Copper Chronic Saltwater` =  signif(6.0 * WER, digits = 2), `Copper PWS` = 1300,
           `Lead Acute Freshwater` = signif(WER * (exp(1.273 * log(criteriaHardness) - 1.084)) * (1.46203 - (log(criteriaHardness) * 0.145712)), digits = 2),
           `Lead Chronic Freshwater` = signif(WER * (exp(1.273 * log(criteriaHardness) - 3.259)) * (1.46203 - (log(criteriaHardness) * 0.145712)), digits = 2),
           `Lead Acute Saltwater` = signif(230 * WER, digits = 2), `Lead Chronic Saltwater` = signif(8.8 * WER, digits = 2), `Lead PWS` = 15,
           `Mercury Acute Freshwater` = 1.4, `Mercury Chronic Freshwater` = 0.77, `Mercury Acute Saltwater` = 1.8, `Mercury Chronic Saltwater` = 0.94,
           `Nickel Acute Freshwater` = signif(WER * (exp (0.8460 * log(criteriaHardness) + 1.312)) * 0.998, digits = 2), 
           `Nickel Chronic Freshwater` = signif(WER * (exp(0.8460 * log(criteriaHardness) - 0.8840)) * 0.997, digits = 2),
           `Nickel Acute Saltwater` = signif(74 * WER, digits = 2), `Nickel Chronic Saltwater` = signif(8.2 * WER, digits = 2), `Nickel PWS` = 610,  `Nickel All Other Surface Waters` = 4600,
           `Uranium PWS` = 30,
           `Selenium Acute Freshwater` = 20, `Selenium Chronic Freshwater` = 5.0, 
           `Selenium Acute Saltwater` = signif(290 * WER, digits = 2), `Selenium Chronic Saltwater` = signif(71 * WER, digits = 2),
           `Selenium PWS` = 170, `Selenium All Other Surface Waters` = 4200,
           `Silver Acute Freshwater` = signif(WER * (exp(1.72 * log(criteriaHardness) - 6.52)) * 0.85, digits = 2), `Silver Acute Saltwater` = signif(1.9 * WER, digits = 2),
           `Thallium PWS` = 0.24, `Thallium All Other Surface Waters` = 0.47,
           `Zinc Acute Freshwater` = signif(WER * (exp(0.8473 * log(criteriaHardness) + 0.884)) * 0.978, digits = 2),
           `Zinc Chronic Freshwater` = signif(WER * (exp(0.8473 * log(criteriaHardness) + 0.884)) * 0.986, digits = 2),
           `Zinc Acute Saltwater` = signif(90 * WER, digits = 2), `Zinc Chronic Saltwater` = signif(81 * WER, digits = 2), 
           `Zinc PWS` = 7400, `Zinc All Other Surface Waters` = 26000) %>% 
      pivot_longer(!ID, names_to = 'Criteria', values_to = 'CriteriaValue') %>% 
      mutate(Criteria2 = Criteria) %>%  #duplicate column to split
      separate(Criteria2, c("Metal", "Criteria Type", "Waterbody"), sep = " ") %>% 
      mutate(`Criteria Type` = ifelse(`Criteria Type` == 'All', 'All Other Waters', `Criteria Type`),
             Waterbody = ifelse(Waterbody == 'Other', NA, Waterbody)) %>% 
      dplyr::select(ID, Metal, Criteria, `Criteria Type`, Waterbody, CriteriaValue))
  return(metalsCriteria)
}
```

#### metalsAnalysis

This function identifies samples within relevant data windows, calculates averages of the data within those windows where necessary (acute and chronic criteria), determines the appropriate criteria to apply using `metalsCriteriaFunction()`, and tallies exceedances based on those criteria.

`metalsAnalysis()` approaches metals assessment by separating the analysis into 3 bins: raw, acute, and chronic. The function loops across individual samples for the station under consideration and creates a dataframe based on the data windows for raw, acute, and chronic criteria. The raw data window simply uses the time that the current sample in the loop was collected. The acute data window will include all site-specific samples taken within an hour of the sample under consideration, whereas the chronic data window will include all samples taken within four days of the sample under consideration.

After these data windows are created for an individual sample, the process described below occurs in succession: first for the raw data, then for acute data, and ending with chronic data. The loop then repeats this process for the next sample at the station under consideration, starting with the creation of a new set of data windows specific to that sample. The process is as follows:

1.  The data are reshaped to facilitate evaluation against criteria. This involves pivoting the data into long format, dropping unnecessary fields, and adding fields used for identification.

2.  A mean value is calculated (only true for acute and chronic assessment).

3.  The criteria are determined using `metalsCriteriaFunction()`. The ID, hardness, and WER for the sample under consideration are used as inputs to this function.

4.  The sample values are rounded to 2 significant figures and compared to the criteria (also set to 2 significant figures).

5.  Exceedances for specific metals are flagged with a value of 1 in the "Exceedance" column and a 0 is returned to this column if there is no exceedance for a given metal.

After this process is completed for all samples at a station, the results from raw, acute, and chronic metals assessment are combined into a single dataframe (`stationCriteriaResults`), which is the output of the function.

Output from the `metalsAnalysis()` function are manipulated to utilize the [`annualRollingExceedanceAnalysis()`](#annualRollingExceedanceAnalysis) and [`annualRollingExceedanceSummary()`](#annualRollingExceedanceSummary) functionality as described in the example below. The result of metals analyses analyzed by the `annualRollingExceedanceSummary()` function is then sent to the `metalsAssessmentFunction()` function.

```{r automated assessment metalsAnalysis, eval=FALSE}
# For use with rolling aquatic life use method
metalsAnalysis <- function(stationMetalsData, stationData, WER){
  # If no WER supplied, use 1
  WER <- ifelse(is.na(WER), 1, WER)
  
  # Get WQS from stationData so correct criteria can be applied
  stationMetalsData <- left_join(stationMetalsData, 
                                 dplyr::select(stationData, FDT_STA_ID, CLASS, PWS, ZONE) %>% 
                                   distinct(FDT_STA_ID, .keep_all = TRUE), by = c('Station_Id' = 'FDT_STA_ID')) %>% 
    mutate(`Assess As` = case_when(CLASS == "I" ~ 'Saltwater',
                                   CLASS == "II" & ZONE == 'Estuarine' ~ 'Saltwater',
                                   CLASS == "II" & ZONE == 'Transition' ~ 'More Stringent',
                                   CLASS == "II" & ZONE == 'Tidal Fresh' ~ 'Freshwater',
                                   CLASS %in% c('III', "IV","V","VI","VII") ~ 'Freshwater',
                                   TRUE ~ as.character(NA)),
           ChromiumIII= Chromium, RMK_ChromiumIII = RMK_Chromium, 
           ChromiumVI= Chromium, RMK_ChromiumVI = RMK_Chromium ) %>% # add individual Chromium variables to make joining to assessment criteria easier
    # Roger uses ChromiumIII and VI to flag any potential chromium issues, likely further lab analyses needed if either chromium criteria blown
    dplyr::select(Station_Id:RMK_Cadmium, ChromiumIII:RMK_ChromiumVI, Cadmium:`Assess As`)
  
  # make a place to store raw analysis results
  rawCriteriaResults <- tibble(Station_Id = as.character(NA), WindowDateTimeStart = as.POSIXct(NA), FDT_DEPTH = as.numeric(NA),
                               CLASS = as.factor(NA), PWS = as.factor(NA), ZONE = as.factor(NA), `Assess As` = as.character(NA),
                               Metal = as.character(NA), Value = as.numeric(NA), ValueType = as.character(NA), Criteria = as.character(NA), 
                               `Criteria Type` = as.character(NA), Waterbody = as.character(NA), CriteriaValue = as.numeric(NA),
                               `Sample Count` = as.numeric(NA),
                               parameterRound = as.numeric(NA), Exceedance = as.numeric(NA))
  acuteCriteriaResults <- rawCriteriaResults 
  chronicCriteriaResults <- acuteCriteriaResults 
  
  # loop through each row of data to correctly calculate criteria and find any chronic scenarios
  for(k in stationMetalsData$FDT_DATE_TIME){
    rawDataWindow <- filter(stationMetalsData, FDT_DATE_TIME == k)
    acuteDataWindow <- filter(stationMetalsData,  between(FDT_DATE_TIME, k, k + hours(1)))
    chronicDataWindow <- filter(stationMetalsData,  between(FDT_DATE_TIME, k, k + days(4)))
    # Run any analyses requiring raw data if data exists
    if(nrow(rawDataWindow) > 0){
      rawData <- rawDataWindow %>% 
        group_by(Station_Id, FDT_DATE_TIME, FDT_DEPTH, CLASS, PWS, ZONE, `Assess As`) %>% 
        dplyr::select(-c(contains('RMK_'))) %>% 
        pivot_longer(cols = Antimony:Hardness, names_to = "Metal", values_to = "Value") %>% 
        mutate(ValueType = 'Raw Result',
               ID = paste(Station_Id, FDT_DATE_TIME, FDT_DEPTH, sep = '_')) %>% # make a uniqueID in case >1 sample for given datetime
        ungroup()
      # Calculate criteria based on raw data
      rawDataCriteria <- metalsCriteriaFunction(filter(rawData, Metal == "Hardness")$ID, filter(rawData, Metal == "Hardness")$Value, WER = 1) %>% 
        filter(`Criteria Type` %in% c('All Other Waters', 'PWS')) %>% # don't need other criteria for acute window
        {if(is.na(unique(rawData$PWS)))
          filter(., `Criteria Type` != 'PWS')
          else .}
      # Join appropriate criteria to rawData for comparison to averaged data
      rawDataCriteriaAnalysis <- left_join(rawData, rawDataCriteria, by = c('ID', 'Metal')) %>% 
        mutate(`Sample Count` = 1, # will be 1 here
               parameterRound = signif(Value, digits = 2), # two significant figures based on WQS https://law.lis.virginia.gov/admincode/title9/agency25/chapter260/section140/
               Exceedance = ifelse(parameterRound > CriteriaValue, 1, 0 ),
               WindowDateTimeStart = min(rawDataWindow$FDT_DATE_TIME)) %>%  # use 1/0 to easily summarize multiple results later
        filter(!is.na(Criteria)) %>%  # filter out metals that don't have chronic criteria
        dplyr::select(Station_Id, WindowDateTimeStart, everything()) %>% 
        dplyr::select(-c(FDT_DATE_TIME, ID))
      # Save the results for viewing later
      rawCriteriaResults <- bind_rows(rawCriteriaResults, rawDataCriteriaAnalysis) 
    } else {rawCriteriaResults <- rawCriteriaResults }
    # Run acute analysis if data exists
    if(nrow(acuteDataWindow) > 0){
      acuteData <- suppressMessages(acuteDataWindow %>% 
                                      group_by(Station_Id, FDT_DEPTH, CLASS, PWS, ZONE, `Assess As`) %>% # can't group by datetime or summary can't happen
                                      dplyr::select(-c(contains('RMK_'))) %>% 
                                      pivot_longer(cols = Antimony:Hardness, names_to = "Metal", values_to = "CriteriaValue") %>% 
                                      ungroup() %>% group_by(Station_Id, FDT_DEPTH, CLASS, PWS, ZONE, `Assess As`, Metal) %>% 
                                      summarise(`Sample Count` = length(CriteriaValue),
                                                Value = mean(CriteriaValue, na.rm=T)) %>%  # get hourly average
                                      mutate(ValueType = 'Hourly Average',
                                             ID = paste(Station_Id, FDT_DEPTH, sep = '_')) ) # make a uniqueID in case >1 sample for given datetime
      # Calculate criteria based on hourly averaged data
      acuteDataCriteria <- metalsCriteriaFunction(filter(acuteData, Metal == "Hardness")$ID, filter(acuteData, Metal == "Hardness")$Value, WER = 1) %>% 
        filter(`Criteria Type` == 'Acute') %>% # don't need other criteria for acute window
        # Keep only the criteria needed 
        {if(unique(acuteData$`Assess As`) %in% c('Freshwater', 'Saltwater'))
          filter(., Waterbody %in% c(NA, !!unique(acuteData$`Assess As`)))
          # if in Transition Zone then use the more stringent standard
          else group_by(., Metal) %>% 
            mutate(MoreStringent = min(CriteriaValue)) %>% 
            filter(CriteriaValue == MoreStringent) %>% 
            dplyr::select(-MoreStringent)} 
      # Join appropriate criteria to acuteData for comparison to averaged data
      acuteDataCriteriaAnalysis <- left_join(acuteData, acuteDataCriteria, by = c('ID', 'Metal')) %>% 
        mutate(parameterRound = signif(Value, digits = 2), # two significant figures based on WQS https://law.lis.virginia.gov/admincode/title9/agency25/chapter260/section140/
               Exceedance = ifelse(parameterRound > CriteriaValue, 1, 0 ), # use 1/0 to easily summarize multiple results later
               WindowDateTimeStart = min(acuteDataWindow$FDT_DATE_TIME)) %>% 
        filter(!is.na(Criteria)) %>% # filter out metals that don't have chronic criteria
        dplyr::select(names(rawDataCriteriaAnalysis))
      # dplyr::select(Station_Id, WindowDateTimeStart, everything(), -ID)      # Save the results for viewing later
      acuteCriteriaResults <- bind_rows(acuteCriteriaResults, acuteDataCriteriaAnalysis) 
    } else {acuteCriteriaResults <- acuteCriteriaResults }
    # Run chronic analysis if data exists
    if(nrow(chronicDataWindow) > 0){
      chronicData <- suppressMessages(chronicDataWindow %>% 
                                        group_by(Station_Id, FDT_DEPTH, CLASS, PWS, ZONE, `Assess As`) %>% # can't group by datetime or summary can't happen
                                        dplyr::select(-c(contains('RMK_'))) %>% 
                                        pivot_longer(cols = Antimony:Hardness, names_to = "Metal", values_to = "CriteriaValue") %>% 
                                        ungroup() %>% group_by(Station_Id, FDT_DEPTH, CLASS, PWS, ZONE, `Assess As`, Metal) %>% 
                                        summarise(`Sample Count` = length(CriteriaValue),
                                                  Value = mean(CriteriaValue, na.rm=T)) %>% # get four day average
                                        mutate(ValueType = 'Four Day Average',
                                               ID = paste(Station_Id, FDT_DEPTH, sep = '_')) ) # make a uniqueID in case >1 sample for given datetime
      # Calculate criteria based on hourly averaged data
      chronicDataCriteria <- metalsCriteriaFunction(filter(chronicData, Metal == "Hardness")$ID, filter(chronicData, Metal == "Hardness")$Value, WER = 1) %>% 
        filter(`Criteria Type` == 'Chronic') %>% # don't need other criteria for chronic window analysis
        # Keep only the criteria needed 
        {if(unique(chronicData$`Assess As`) %in% c('Freshwater', 'Saltwater'))
          filter(., Waterbody %in% c(NA, !!unique(chronicData$`Assess As`)))
          # if in Transition Zone then use the more stringent standard
          else group_by(., Metal) %>% 
            mutate(MoreStringent = min(CriteriaValue)) %>% 
            filter(CriteriaValue == MoreStringent) %>% 
            dplyr::select(-MoreStringent)} 
      # Join appropriate criteria to chronicData for comparison to averaged data
      chronicDataCriteriaAnalysis <- left_join(chronicData, chronicDataCriteria, by = c('ID', 'Metal')) %>% 
        mutate(parameterRound = signif(Value, digits = 2), # two significant figures based on WQS https://law.lis.virginia.gov/admincode/title9/agency25/chapter260/section140/
               Exceedance = ifelse(parameterRound > CriteriaValue, 1, 0 ), # use 1/0 to easily summarize multiple results later
               WindowDateTimeStart = min(chronicDataWindow$FDT_DATE_TIME)) %>% 
        filter(!is.na(Criteria)) %>% # filter out metals that don't have chronic criteria
        dplyr::select(names(rawDataCriteriaAnalysis))
      # dplyr::select(Station_Id, WindowDateTimeStart, everything(), -ID)
      # Save the results for viewing later
      chronicCriteriaResults <- bind_rows(chronicCriteriaResults, chronicDataCriteriaAnalysis) 
    } else {chronicCriteriaResults <- chronicCriteriaResults }
  }
  stationCriteriaResults <- bind_rows(rawCriteriaResults, acuteCriteriaResults, chronicCriteriaResults) %>% 
    filter(!is.na(Station_Id)) %>% # drop placeholder rows
    distinct(Station_Id, WindowDateTimeStart, FDT_DEPTH, Criteria, .keep_all = T) %>% # remove duplicates in case > 1 depth per datetime
    arrange(Station_Id, WindowDateTimeStart, FDT_DEPTH, Metal)
  return(stationCriteriaResults)
}

# Example Usage: (demonstrating nested function syntax and pipes, both result in the same output):
# where stationData and WCmetalsForAnalysis objects are already in your environment, see Automated Assessment for environment set up help
# metalsAnalysis(filter(WCmetalsForAnalysis, Station_Id %in%  stationData$FDT_STA_ID), stationData, WER= 1)
# filter(WCmetalsForAnalysis, Station_Id %in%  stationData$FDT_STA_ID) %>%
#   metalsAnalysis(stationData, WER= 1) 

# Example usage with rolling analyses
# filter(WCmetalsForAnalysis, Station_Id %in%  stationData$FDT_STA_ID) %>% 
#       metalsAnalysis( stationData, WER = 1) %>% 
#       rename(FDT_STA_ID = Station_Id) %>% 
#       mutate(`Criteria Type` = Criteria) %>% 
#       annualRollingExceedanceAnalysis(yearsToRoll = 3, aquaticLifeUse = TRUE) %>% 
#       annualRollingExceedanceSummary()
```

#### metalsAssessmentFunction

This final function analyzes the output of `metalsAnalysis()` function that was run through the rolling window summary functions, and converts it into the stations table format. However, because there are multiple metals and only 2 columns in the stations table available to describe these results, the total number of exceedances across all metals for a station is reported in the WAT_MET_EXC field. The WAT_MET_STAT field returns "S" if no exceedances exist and "Review" if any exceedances are found in any metal. In the WAT_MET_COMMENT field, this function returns a string that includes the criteria that were exceeded with the number of exceedances in parentheses (e.g., Cadmium Chronic Freshwater (2), Barium PWS (1), Copper Acute Freshwater (4), etc.). The WAT_MET_COMMENT is not reported directly in the Station Table but is instead combined into the overall station COMMENT field to comply with standardized assessment application features. 

```{r automated assessment metalsAssessmentFunction, eval=FALSE}
# Metals Assessment function that makes sense of output from metalsAnalysis() passed through the rolling window functions
metalsAssessmentFunction <- function(metalsAnalysisResults){
  #Check to make sure that metals data exist
  if(nrow(metalsAnalysisResults) > 0){
    
    #  Organize results to include Station_Id, Criteria, and the # of Exceedances
    metalsExceedances <- metalsAnalysisResults %>%
      group_by(FDT_STA_ID, `Criteria Type` ) %>%
      summarise(Exceedances = sum(`n Windows Exceeding`, na.rm = T)) %>%
      arrange(`Criteria Type`) %>%  # arrange on just Criteria to make column order make more sense
      filter(Exceedances > 0)
    
    # If there are any exceedances, create a string that includes the metal name(s) and the number of exceedances in parentheses
    if(nrow(metalsExceedances)>0){
      WAT_MET_STATstring<-sapply(seq_len(nrow(metalsExceedances)), function(i) paste0(metalsExceedances$`Criteria Type`[i]," (", metalsExceedances$Exceedances[i], ")")) %>%
        toString()
      # Create tibble in the format of the stations table that takes the sum of all exceedances for the WAT_MET_EXC field and returns the string created above for the WAT_MET_STAT field
      metalsResults <- tibble("WAT_MET_EXC" = sum(metalsExceedances$Exceedances), "WAT_MET_STAT" = "Review", "WAT_MET_COMMENT" = WAT_MET_STATstring)
    }else{
      # If metals data do exist, but there are no exceedances, return 0 and "S" for supporting
      metalsResults <- tibble("WAT_MET_EXC" = 0, "WAT_MET_STAT" = "S", "WAT_MET_COMMENT" = NA)
    }}else{
      # If no metals data exist, return a tibble with NA for both fields
      metalsResults <- tibble("WAT_MET_EXC" = NA, "WAT_MET_STAT" = NA, "WAT_MET_COMMENT" = NA)
    }    
  return(metalsResults)
}


# Example Usage for Station Table (demonstrating nested function syntax and pipes, both result in the same output):
# where stationData and WCmetalsForAnalysis objects are already in your environment, see Automated Assessment for environment set up help
# filter(WCmetalsForAnalysis, Station_Id %in%  stationData$FDT_STA_ID) %>% 
#       metalsAnalysis( stationData, WER = 1) %>% 
#       rename(FDT_STA_ID = Station_Id) %>% 
#       mutate(`Criteria Type` = Criteria) %>% 
#       annualRollingExceedanceAnalysis(yearsToRoll = 3, aquaticLifeUse = TRUE) %>% 
#       annualRollingExceedanceSummary() %>% 
#       metalsAssessmentFunction()

```
